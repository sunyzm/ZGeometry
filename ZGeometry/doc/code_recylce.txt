/* code on geodesic computation */
class GeoNote
{
public:
    int m_id;
    double m_geodesic;
public:
    GeoNote(int mid, double geo) { m_id = mid; m_geodesic = geo; }
    GeoNote& operator = (const GeoNote& note) { m_id = note.m_id; m_geodesic = note.m_geodesic; return(*this); }
    friend bool operator > (const GeoNote& note1, const GeoNote& note2) { return note1.m_geodesic > note2.m_geodesic; }
};
typedef std::priority_queue<GeoNote, std::vector<GeoNote>, std::greater<GeoNote> > GeoQueue;

double CMesh::calLocalGeodesic(int ia, int ib, int ic) const
{
    // ia - vertex with smaller geodesic; ib - with greater geodesic; ic - update
    double la = (m_pVertex[ib].m_vPosition - m_pVertex[ic].m_vPosition).length();
    double lb = (m_pVertex[ia].m_vPosition - m_pVertex[ic].m_vPosition).length();
    double lc = (m_pVertex[ib].m_vPosition - m_pVertex[ia].m_vPosition).length();
    double ctheta = (la*la + lb*lb - lc*lc) / (2 * la*lb);
    double stheta = sqrt(1 - ctheta*ctheta);
    double u = m_pVertex[ib].m_LocalGeodesic - m_pVertex[ia].m_LocalGeodesic;
    double ld = lb - la*ctheta;
    double le = la*stheta;
    double delta = lc*lc - u*u;
    double tc = m_pVertex[ic].m_LocalGeodesic;
    if (delta >= 0.0) {
        delta = sqrt(delta);
        double t1 = lb*(u*ld + le*delta) / (lc*lc);//(-B+delta)/(2*A);
        if (t1 > u && lb*(t1 - u) / t1 > la*ctheta && lb*(t1 - u) / t1 < la / abs(ctheta))
        {
            if (tc < 0.0) tc = t1 + m_pVertex[ia].m_LocalGeodesic;
            else tc = min(tc, t1 + m_pVertex[ia].m_LocalGeodesic);
        }
        else
        {
            double minab = min(lb + m_pVertex[ia].m_LocalGeodesic, la + m_pVertex[ib].m_LocalGeodesic);
            if (tc < 0.0) tc = minab;
            else tc = min(tc, minab);
        }
    }
    else {
        double minab = min(lb + m_pVertex[ia].m_LocalGeodesic, la + m_pVertex[ib].m_LocalGeodesic);
        if (tc < 0.0) tc = minab;
        else tc = min(tc, minab);
    }
    return tc;
}

double CMesh::calGeodesic(int s, int t) const
{
    if (s == t) return 0.0;

    GeoQueue heapqueue;

    vector<GeoNote> nbg;
    CVertex& notei = m_pVertex[s];
    notei.m_mark = s;
    notei.m_LocalGeodesic = 0.0;
    notei.m_inheap = true;
    nbg.push_back(GeoNote(s, 0.0));

    int size = notei.mOutValence;
    int j, k, ia, ib, ic;

    bool stop = false;
    double geo = 0.0;

    for (j = 0; j < size; j++)
    {
        int ee = notei.m_piEdge[j];
        int endv = m_pHalfEdge[ee].m_iVertex[1];
        Vector3D vt = m_pVertex[endv].m_vPosition - m_pVertex[s].m_vPosition;
        double mgeo = vt.length();

        if (endv == t) { stop = true; geo = mgeo; break; }	// destination reached
        m_pVertex[endv].m_inheap = true;
        m_pVertex[endv].m_LocalGeodesic = mgeo;   // geodesic in first ring
        m_pVertex[endv].m_mark = s;
        nbg.push_back(GeoNote(endv, mgeo));
    }
    if (!stop)
    {
        for (j = 0; j < size; j++)
        {
            int e1 = notei.m_piEdge[j];
            ia = m_pHalfEdge[e1].m_iVertex[1];
            int e2 = m_pHalfEdge[e1].m_iNextEdge;
            ib = m_pHalfEdge[e2].m_iVertex[1];
            if (m_pVertex[ia].m_LocalGeodesic > m_pVertex[ib].m_LocalGeodesic)
            {
                int it = ia;
                ia = ib;
                ib = it;
            }
            e1 = m_pHalfEdge[e2].m_iTwinEdge;
            if (e1 < 0) continue;
            e2 = m_pHalfEdge[e1].m_iNextEdge;
            ic = m_pHalfEdge[e2].m_iVertex[1];
            double mgeo = calLocalGeodesic(ia, ib, ic);
            m_pVertex[ic].m_LocalGeodesic = mgeo;
            m_pVertex[ic].m_inheap = true;
            heapqueue.push(GeoNote(ic, mgeo));
        } // first ring
    }

    while (!stop && !heapqueue.empty())
    {
        //if(++count == m_nVertex) {break;}
        //cout << ++count << endl;
        GeoNote nt = heapqueue.top();
        heapqueue.pop();

        int sg = nt.m_id;
        if (sg == t)
        {
            stop = true;
            geo = nt.m_geodesic;
            nbg.push_back(nt);
            break;
        }

        double sgd = nt.m_geodesic;
        //		if(m_pVertex[sg].m_bIsBoundary) continue;
        if (m_pVertex[sg].m_mark == s) continue;  // matched already
        m_pVertex[sg].m_mark = s;
        nbg.push_back(nt);
        // update adjacent vertices of sg
        for (k = 0; k < m_pVertex[sg].mOutValence; k++)
        {
            ia = sg;
            int e1 = m_pVertex[sg].m_piEdge[k];
            ib = m_pHalfEdge[e1].m_iVertex[1];
            if (m_pVertex[ib].m_mark != s) continue; // unreached point
            int e2 = m_pHalfEdge[e1].m_iNextEdge;
            if (m_pVertex[ia].m_LocalGeodesic > m_pVertex[ib].m_LocalGeodesic)
            {
                ia = ib;
                ib = sg;
            }
            ic = m_pHalfEdge[e2].m_iVertex[1];
            if (m_pVertex[ic].m_mark != s)
            {
                double gg = calLocalGeodesic(ia, ib, ic);   // update geodesic
                if (m_pVertex[ic].m_LocalGeodesic < 0.0f)
                {
                    m_pVertex[ic].m_LocalGeodesic = gg;
                    m_pVertex[ic].m_inheap = true;
                    heapqueue.push(GeoNote(ic, gg));
                }
                else if (gg < m_pVertex[ic].m_LocalGeodesic) // heaped, shorter patch came
                {
                    m_pVertex[ic].m_LocalGeodesic = gg;
                    m_pVertex[ic].m_inheap = true;
                    heapqueue.push(GeoNote(ic, gg));
                }
            }
            e2 = m_pHalfEdge[e1].m_iTwinEdge;
            if (e2 < 0 || e2 >= m_nHalfEdge) continue;
            e1 = m_pHalfEdge[e2].m_iNextEdge;
            ic = m_pHalfEdge[e1].m_iVertex[1];
            if (m_pVertex[ic].m_mark != s)
            {
                double gg = calLocalGeodesic(ia, ib, ic);   // update geodesic
                if (m_pVertex[ic].m_LocalGeodesic < 0.0f)
                {
                    m_pVertex[ic].m_LocalGeodesic = gg;
                    m_pVertex[ic].m_inheap = true;
                    heapqueue.push(GeoNote(ic, gg));
                }
                else if (gg < m_pVertex[ic].m_LocalGeodesic) // heaped, shorter patch came
                {
                    m_pVertex[ic].m_LocalGeodesic = gg;
                    m_pVertex[ic].m_inheap = true;
                    heapqueue.push(GeoNote(ic, gg));
                }
            }
        }
    }

    for (size_t ni = 0; ni < nbg.size(); ni++)
    {
        int pos = nbg[ni].m_id;
        m_pVertex[pos].m_mark = -1;
        m_pVertex[pos].m_LocalGeodesic = -1.0;
        m_pVertex[pos].m_inheap = false;
    }
    // clear heap
    while (!heapqueue.empty())
    {
        GeoNote nt = heapqueue.top();
        heapqueue.pop();
        int pos = nt.m_id;
        m_pVertex[pos].m_mark = -1;
        m_pVertex[pos].m_LocalGeodesic = -1.0;
        m_pVertex[pos].m_inheap = false;
    }

    return geo;
}

bool CMesh::vertGeoNeighborVerts(int i, double ring, vector<GeoNote>& nbg)
{
    GeoQueue heapqueue;

    if (!nbg.empty()) nbg.clear();

    CVertex& notei = m_pVertex[i];
    notei.m_mark = i;
    notei.m_LocalGeodesic = 0.0;
    notei.m_inheap = true;
    nbg.push_back(GeoNote(i, 0.0));

    int size = notei.mOutValence;
    int j, k, ia, ib, ic;

    bool flag = true;

    for (j = 0; j < size; j++) {
        int ee = notei.m_piEdge[j];
        int endv = m_pHalfEdge[ee].m_iVertex[1];
        m_pVertex[endv].m_inheap = true;
        Vector3D vt = m_pVertex[endv].m_vPosition - m_pVertex[i].m_vPosition;
        double mgeo = vt.length();
        m_pVertex[endv].m_LocalGeodesic = mgeo;   // geodesic in first ring
        m_pVertex[endv].m_mark = i;
        if (mgeo < ring) nbg.push_back(GeoNote(endv, mgeo));
    }

    for (j = 0; j < size; j++) {
        int e1 = notei.m_piEdge[j];
        ia = m_pHalfEdge[e1].m_iVertex[1];
        int e2 = m_pHalfEdge[e1].m_iNextEdge;
        ib = m_pHalfEdge[e2].m_iVertex[1];
        if (m_pVertex[ia].m_LocalGeodesic > m_pVertex[ib].m_LocalGeodesic) {
            int it = ia;
            ia = ib;
            ib = it;
        }
        e1 = m_pHalfEdge[e2].m_iTwinEdge;
        if (e1 < 0) continue;
        e2 = m_pHalfEdge[e1].m_iNextEdge;
        ic = m_pHalfEdge[e2].m_iVertex[1];
        double mgeo = calLocalGeodesic(ia, ib, ic);
        m_pVertex[ic].m_LocalGeodesic = mgeo;
        m_pVertex[ic].m_inheap = true;
        if (mgeo < ring) heapqueue.push(GeoNote(ic, mgeo));
    } // first ring

    int itr = 0;
    while (!heapqueue.empty())// && itr<MAX_NEIGHBOR_NUMBER) 
    {
        itr++;
        GeoNote nt = heapqueue.top();
        heapqueue.pop();

        int sg = nt.m_id;
        double sgd = nt.m_geodesic;
        if (m_pVertex[sg].m_bIsBoundary) flag = false;

        if (m_pVertex[sg].m_mark == i) continue;  // marched already
        //if(m_pOctave[o].m_pNote[sg].m_LocalGeodesic < sgd) continue;
        if (m_pVertex[sg].m_LocalGeodesic > ring) break;   // reach the upper bound
        nbg.push_back(nt);
        m_pVertex[sg].m_mark = i;

        // update adjacent vertices of sg
        for (k = 0; k < m_pVertex[sg].mOutValence; k++) {
            ia = sg;
            int e1 = m_pVertex[sg].m_piEdge[k];
            ib = m_pHalfEdge[e1].m_iVertex[1];
            if (m_pVertex[ib].m_mark != i) continue; // unreached point
            int e2 = m_pHalfEdge[e1].m_iNextEdge;
            if (m_pVertex[ia].m_LocalGeodesic > m_pVertex[ib].m_LocalGeodesic)
            {
                ia = ib;
                ib = sg;
            }
            ic = m_pHalfEdge[e2].m_iVertex[1];
            if (m_pVertex[ic].m_mark != i)
            {
                double gg = calLocalGeodesic(ia, ib, ic);   // update geodesic
                if (m_pVertex[ic].m_LocalGeodesic < 0.0f)
                {
                    m_pVertex[ic].m_LocalGeodesic = gg;
                    m_pVertex[ic].m_inheap = true;
                    if (gg < ring) heapqueue.push(GeoNote(ic, gg));
                }
                else if (gg < m_pVertex[ic].m_LocalGeodesic) // heaped, shorter patch came
                {
                    m_pVertex[ic].m_LocalGeodesic = gg;
                    m_pVertex[ic].m_inheap = true;
                    if (gg < ring) heapqueue.push(GeoNote(ic, gg));
                }
            }
            e2 = m_pHalfEdge[e1].m_iTwinEdge;
            if (e2 < 0 || e2 >= m_nHalfEdge) continue;
            e1 = m_pHalfEdge[e2].m_iNextEdge;
            ic = m_pHalfEdge[e1].m_iVertex[1];
            if (m_pVertex[ic].m_mark != i)
            {
                double gg = calLocalGeodesic(ia, ib, ic);   // update geodesic
                if (m_pVertex[ic].m_LocalGeodesic < 0.0f)
                {
                    m_pVertex[ic].m_LocalGeodesic = gg;
                    m_pVertex[ic].m_inheap = true;
                    if (gg < ring) heapqueue.push(GeoNote(ic, gg));
                }
                else if (gg < m_pVertex[ic].m_LocalGeodesic) // heaped, shorter patch came
                {
                    m_pVertex[ic].m_LocalGeodesic = gg;
                    m_pVertex[ic].m_inheap = true;
                    if (gg < ring) heapqueue.push(GeoNote(ic, gg));
                }
            }
        }
    }

    for (size_t ni = 0; ni < nbg.size(); ni++)
    {
        int pos = nbg[ni].m_id;
        m_pVertex[pos].m_mark = -1;
        m_pVertex[pos].m_LocalGeodesic = -1.0;
        m_pVertex[pos].m_inheap = false;
    }
    // clear heap
    while (!heapqueue.empty())
    {
        GeoNote nt = heapqueue.top();
        heapqueue.pop();
        int pos = nt.m_id;
        m_pVertex[pos].m_mark = -1;
        m_pVertex[pos].m_LocalGeodesic = -1.0;
        m_pVertex[pos].m_inheap = false;
    }

    return flag;
}

double CMesh::getGeodesicToBoundary(int s) const
{
    GeoQueue heapqueue;

    vector<GeoNote> nbg;
    CVertex& notei = m_pVertex[s];
    notei.m_mark = s;
    notei.m_LocalGeodesic = 0.0;
    notei.m_inheap = true;
    nbg.push_back(GeoNote(s, 0.0));

    int size = notei.mOutValence;
    int j, k, ia, ib, ic;

    bool stop = false;
    double geo = 0.0;

    const std::vector<bool>& vVertIsHole = getVertsOnHole_const();

    for (j = 0; j < size; j++)
    {
        int ee = notei.m_piEdge[j];
        int endv = m_pHalfEdge[ee].m_iVertex[1];
        Vector3D vt = m_pVertex[endv].m_vPosition - m_pVertex[s].m_vPosition;
        double mgeo = vt.length();

        if (m_pVertex[endv].m_bIsBoundary && !vVertIsHole[endv]) { stop = true; geo = mgeo; break; }	// destination reached
        m_pVertex[endv].m_inheap = true;
        m_pVertex[endv].m_LocalGeodesic = mgeo;   // geodesic in first ring
        m_pVertex[endv].m_mark = s;
        nbg.push_back(GeoNote(endv, mgeo));
    }
    if (!stop)
    {
        for (j = 0; j < size; j++)
        {
            int e1 = notei.m_piEdge[j];
            ia = m_pHalfEdge[e1].m_iVertex[1];
            int e2 = m_pHalfEdge[e1].m_iNextEdge;
            ib = m_pHalfEdge[e2].m_iVertex[1];
            if (m_pVertex[ia].m_LocalGeodesic > m_pVertex[ib].m_LocalGeodesic)
            {
                int it = ia;
                ia = ib;
                ib = it;
            }
            e1 = m_pHalfEdge[e2].m_iTwinEdge;
            if (e1 < 0) continue;
            e2 = m_pHalfEdge[e1].m_iNextEdge;
            ic = m_pHalfEdge[e2].m_iVertex[1];
            double mgeo = calLocalGeodesic(ia, ib, ic);
            m_pVertex[ic].m_LocalGeodesic = mgeo;
            m_pVertex[ic].m_inheap = true;
            heapqueue.push(GeoNote(ic, mgeo));
        } // first ring
    }

    int count = -m_nVertex;
    while (!stop && !heapqueue.empty())
    {
        if (++count == m_nVertex) { break; }

        GeoNote nt = heapqueue.top();
        heapqueue.pop();

        int sg = nt.m_id;
        if (m_pVertex[sg].m_bIsBoundary && !vVertIsHole[sg])
        {
            stop = true;
            geo = nt.m_geodesic;
            nbg.push_back(nt);
            break;
        }

        double sgd = nt.m_geodesic;

        if (m_pVertex[sg].m_mark == s) continue;  // marched already
        m_pVertex[sg].m_mark = s;
        if (vVertIsHole[sg]) continue;
        nbg.push_back(nt);
        // update adjacent vertices of sg
        for (k = 0; k < m_pVertex[sg].mOutValence; k++)
        {
            ia = sg;
            int e1 = m_pVertex[sg].m_piEdge[k];
            ib = m_pHalfEdge[e1].m_iVertex[1];
            if (m_pVertex[ib].m_mark != s) continue; // unreached point
            int e2 = m_pHalfEdge[e1].m_iNextEdge;
            if (m_pVertex[ia].m_LocalGeodesic > m_pVertex[ib].m_LocalGeodesic)
            {
                ia = ib;
                ib = sg;
            }
            ic = m_pHalfEdge[e2].m_iVertex[1];
            if (m_pVertex[ic].m_mark != s)
            {
                double gg = calLocalGeodesic(ia, ib, ic);   // update geodesic
                if (m_pVertex[ic].m_LocalGeodesic < 0.0f)
                {
                    m_pVertex[ic].m_LocalGeodesic = gg;
                    m_pVertex[ic].m_inheap = true;
                    heapqueue.push(GeoNote(ic, gg));
                }
                else if (gg < m_pVertex[ic].m_LocalGeodesic) // heaped, shorter patch came
                {
                    m_pVertex[ic].m_LocalGeodesic = gg;
                    m_pVertex[ic].m_inheap = true;
                    heapqueue.push(GeoNote(ic, gg));
                }
            }
            e2 = m_pHalfEdge[e1].m_iTwinEdge;
            if (e2 < 0 || e2 >= m_nHalfEdge) continue;
            e1 = m_pHalfEdge[e2].m_iNextEdge;
            ic = m_pHalfEdge[e1].m_iVertex[1];
            if (m_pVertex[ic].m_mark != s)
            {
                double gg = calLocalGeodesic(ia, ib, ic);   // update geodesic
                if (m_pVertex[ic].m_LocalGeodesic < 0.0f)
                {
                    m_pVertex[ic].m_LocalGeodesic = gg;
                    m_pVertex[ic].m_inheap = true;
                    heapqueue.push(GeoNote(ic, gg));
                }
                else if (gg < m_pVertex[ic].m_LocalGeodesic) // heaped, shorter patch came
                {
                    m_pVertex[ic].m_LocalGeodesic = gg;
                    m_pVertex[ic].m_inheap = true;
                    heapqueue.push(GeoNote(ic, gg));
                }
            }
        }
    }

    for (size_t ni = 0; ni < nbg.size(); ni++)
    {
        int pos = nbg[ni].m_id;
        m_pVertex[pos].m_mark = -1;
        m_pVertex[pos].m_LocalGeodesic = -1.0;
        m_pVertex[pos].m_inheap = false;
    }
    // clear heap
    while (!heapqueue.empty())
    {
        GeoNote nt = heapqueue.top();
        heapqueue.pop();
        int pos = nt.m_id;
        m_pVertex[pos].m_mark = -1;
        m_pVertex[pos].m_LocalGeodesic = -1.0;
        m_pVertex[pos].m_inheap = false;
    }

    return geo;
}

double CMesh::getGeodesicToBoundary(int s, vector<GeoNote>& nbg)
{
    GeoQueue heapqueue;
    if (!nbg.empty()) nbg.clear();

    CVertex& notei = m_pVertex[s];
    notei.m_mark = s;
    notei.m_LocalGeodesic = 0.0;
    notei.m_inheap = true;
    nbg.push_back(GeoNote(s, 0.0));

    int size = notei.mOutValence;
    int j, k, ia, ib, ic;

    bool stop = false;
    double geo = 0.0;
    const std::vector<bool>& vVertIsHole = getVertsOnHole();

    for (j = 0; j < size; j++)
    {
        int ee = notei.m_piEdge[j];
        int endv = m_pHalfEdge[ee].m_iVertex[1];
        Vector3D vt = m_pVertex[endv].m_vPosition - m_pVertex[s].m_vPosition;
        double mgeo = vt.length();

        if (m_pVertex[endv].m_bIsBoundary && !vVertIsHole[endv]) { stop = true; geo = mgeo; break; }	// destination reached
        m_pVertex[endv].m_inheap = true;
        m_pVertex[endv].m_LocalGeodesic = mgeo;   // geodesic in first ring
        m_pVertex[endv].m_mark = s;
        nbg.push_back(GeoNote(endv, mgeo));
    }
    if (!stop)
    {
        for (j = 0; j < size; j++)
        {
            int e1 = notei.m_piEdge[j];
            ia = m_pHalfEdge[e1].m_iVertex[1];
            int e2 = m_pHalfEdge[e1].m_iNextEdge;
            ib = m_pHalfEdge[e2].m_iVertex[1];
            if (m_pVertex[ia].m_LocalGeodesic > m_pVertex[ib].m_LocalGeodesic)
            {
                int it = ia;
                ia = ib;
                ib = it;
            }
            e1 = m_pHalfEdge[e2].m_iTwinEdge;
            if (e1 < 0) continue;
            e2 = m_pHalfEdge[e1].m_iNextEdge;
            ic = m_pHalfEdge[e2].m_iVertex[1];
            double mgeo = calLocalGeodesic(ia, ib, ic);
            m_pVertex[ic].m_LocalGeodesic = mgeo;
            m_pVertex[ic].m_inheap = true;
            heapqueue.push(GeoNote(ic, mgeo));
        } // first ring
    }

    int count = 0;
    while (!stop && !heapqueue.empty())
    {
        if (++count == m_nVertex) count = count;
        if (s == 2576)
        {
            cout << count << endl;
        }
        GeoNote nt = heapqueue.top();
        heapqueue.pop();

        int sg = nt.m_id;
        if (m_pVertex[sg].m_bIsBoundary && !vVertIsHole[sg])
        {
            stop = true;
            geo = nt.m_geodesic;
            nbg.push_back(nt);
            break;
        }

        double sgd = nt.m_geodesic;

        if (m_pVertex[sg].m_mark == s) continue;  // marched already
        m_pVertex[sg].m_mark = s;
        if (vVertIsHole[sg]) continue;

        nbg.push_back(nt);
        // update adjacent vertices of sg
        for (k = 0; k < m_pVertex[sg].mOutValence; k++)
        {
            ia = sg;
            int e1 = m_pVertex[sg].m_piEdge[k];
            ib = m_pHalfEdge[e1].m_iVertex[1];
            if (m_pVertex[ib].m_mark != s) continue; // unreached point
            int e2 = m_pHalfEdge[e1].m_iNextEdge;
            if (m_pVertex[ia].m_LocalGeodesic > m_pVertex[ib].m_LocalGeodesic)
            {
                ia = ib;
                ib = sg;
            }
            ic = m_pHalfEdge[e2].m_iVertex[1];
            if (m_pVertex[ic].m_mark != s)
            {
                double gg = calLocalGeodesic(ia, ib, ic);   // update geodesic
                if (m_pVertex[ic].m_LocalGeodesic < 0.0f)
                {
                    m_pVertex[ic].m_LocalGeodesic = gg;
                    m_pVertex[ic].m_inheap = true;
                    heapqueue.push(GeoNote(ic, gg));
                }
                else if (gg < m_pVertex[ic].m_LocalGeodesic) // heaped, shorter patch came
                {
                    m_pVertex[ic].m_LocalGeodesic = gg;
                    m_pVertex[ic].m_inheap = true;
                    heapqueue.push(GeoNote(ic, gg));
                }
            }
            e2 = m_pHalfEdge[e1].m_iTwinEdge;
            if (e2 < 0 || e2 >= m_nHalfEdge) continue;
            e1 = m_pHalfEdge[e2].m_iNextEdge;
            ic = m_pHalfEdge[e1].m_iVertex[1];
            if (m_pVertex[ic].m_mark != s)
            {
                double gg = calLocalGeodesic(ia, ib, ic);   // update geodesic
                if (m_pVertex[ic].m_LocalGeodesic < 0.0f)
                {
                    m_pVertex[ic].m_LocalGeodesic = gg;
                    m_pVertex[ic].m_inheap = true;
                    heapqueue.push(GeoNote(ic, gg));
                }
                else if (gg < m_pVertex[ic].m_LocalGeodesic) // heaped, shorter patch came
                {
                    m_pVertex[ic].m_LocalGeodesic = gg;
                    m_pVertex[ic].m_inheap = true;
                    heapqueue.push(GeoNote(ic, gg));
                }
            }
        }
    }

    for (size_t ni = 0; ni < nbg.size(); ni++)
    {
        int pos = nbg[ni].m_id;
        m_pVertex[pos].m_mark = -1;
        m_pVertex[pos].m_LocalGeodesic = -1.0;
        m_pVertex[pos].m_inheap = false;
    }
    // clear heap
    while (!heapqueue.empty())
    {
        GeoNote nt = heapqueue.top();
        heapqueue.pop();
        int pos = nt.m_id;
        m_pVertex[pos].m_mark = -1;
        m_pVertex[pos].m_LocalGeodesic = -1.0;
        m_pVertex[pos].m_inheap = false;
    }

    //if(geo==0.0) cout<<s<<endl;
    return geo;
}


void CMesh::calLBO( std::vector<int>& vII, std::vector<int>& vJJ, std::vector<double>& vSS, std::vector<double>& vArea ) const
{
	vII.clear();
	vJJ.clear();
	vSS.clear();
	vArea.clear();

	int m_size = m_nVertex;
	vector<double> diagW;
	diagW.resize(m_size, 0);	

	for (int i = 0; i < m_size; ++i)	// for every vertex
	{
		double amix = 0.0;		// mixed area
		int bs = -1;
		for( int j = 0; j < m_pVertex[i].mOutValence; j++ ) {
			// get triangle edges
			int e0 = m_pVertex[i].m_piEdge[j];
			int e1 = m_pHalfEdge[e0].m_iNextEdge;
			int e2 = m_pHalfEdge[e1].m_iNextEdge;
			int vj = m_pHalfEdge[e0].m_iVertex[1];
			if (m_pVertex[i].m_bIsBoundary && m_pHalfEdge[e2].m_iTwinEdge < 0)   // boundary vertex
			{
				bs = e2;		// find the last edge incident to vi
			}
			// get edge lengths
			double len0 = getHalfEdgeLen(e0);
			double len1 = getHalfEdgeLen(e1);
			double len2 = getHalfEdgeLen(e2);
			double cota11(0), cota12(0), cota21(0), cota22(0);

			amix += calAreaMixed(len0, len1, len2, cota11, cota12);

			// twin edge
			e0 = m_pHalfEdge[e0].m_iTwinEdge;
			if (e0 > -1) {
				e1 = m_pHalfEdge[e0].m_iNextEdge;
				e2 = m_pHalfEdge[e1].m_iNextEdge;
				/* get edge lengths */
				len1 = getHalfEdgeLen(e1);
				len2 = getHalfEdgeLen(e2);
				/* compute corner angle by cotangent law */
				ZGeom::triangleCot(len0, len1, len2, cota21, cota22);
			}
			double cota = (cota11 + cota21) / 2.0;

			vII.push_back(i+1);	// 1-based index
			vJJ.push_back(vj+1);
			vSS.push_back(cota);
			diagW[i] -= cota;
		}

		if(bs >- 1) {
			int e1 = m_pHalfEdge[bs].m_iNextEdge;
			int	e2 = m_pHalfEdge[e1].m_iNextEdge;
			int vj = m_pHalfEdge[e2].m_iVertex[1];
			assert(vj == m_pHalfEdge[bs].m_iVertex[0]);
			/* get edge lengths */
			double len0 = getHalfEdgeLen(bs);
			double len1 = getHalfEdgeLen(e1);
			double len2 = getHalfEdgeLen(e2);
			/* compute corner angle by cotangent law */
			double cota1, cota2;
			ZGeom::triangleCot(len0, len1, len2, cota1, cota2);
			double cota = cota1 / 2.0;		

			vII.push_back(i+1);
			vJJ.push_back(vj+1);
			vSS.push_back(cota);
			diagW[i] -= cota;
		}

		vArea.push_back(amix);
	}

	for (int i = 0; i < m_size; ++i) {
		vII.push_back(i+1);
		vJJ.push_back(i+1);
		vSS.push_back(diagW[i]);
	}
}


class ManifoldHarmonics
{
public:
	ManifoldHarmonics() : m_size(0), m_nEigFunc(0) {}
	void write(const std::string& meshPath, bool binaryMode = true) const;
	void read(const std::string& meshPath, bool binaryMode = true);
	MeshFunction getManifoldHarmonic(int k) const;
	void dumpEigenValues(const std::string& evlPath) const;
	bool empty() const { return m_func.empty(); }
    int eigVecSize() const { return m_size; }
    int eigVecCount() const { return m_nEigFunc; } 

public:
	std::vector<ManifoldBasis> m_func;	// manifold harmonic basis
	int m_size;	    // shape size
	int m_nEigFunc; // number of basis < shape size
};

void ManifoldHarmonics::write( const std::string& meshPath, bool binaryMode /*= true*/ ) const
{
	if (binaryMode)
	{
		ofstream ofs(meshPath.c_str(), ios::trunc|ios::binary);
		ofs.write((char*)&m_nEigFunc, sizeof(int));
		ofs.write((char*)&m_size, sizeof(int));
		double *buf = new double[m_nEigFunc*(m_size+1)];
		for (int i = 0; i < m_nEigFunc; ++i)
		{
			buf[i * (m_size+1)] = m_func[i].m_val;
			for (int j = 0; j < m_size; ++j)
			{
				buf[i*(m_size+1)+j+1] = m_func[i].m_vec[j];
			}
		}
		ofs.write((char*)buf, sizeof(double)*m_nEigFunc*(m_size+1));
		delete []buf;
		ofs.close();
	}
	else
	{
		ofstream ofs(meshPath.c_str(), ios::trunc);
		ofs << m_nEigFunc << endl;
		ofs << m_size << endl;
		for (int i = 0; i < m_nEigFunc; ++i)
		{
			ofs << m_func[i].m_val;
			for (int j = 0; j < m_size; ++j)
				ofs << ' ' << m_func[i].m_vec[j];
			ofs << endl;
		}
		ofs.close();
	}
	
	cout << "MHB saved to " << meshPath << endl;
}

void ManifoldHarmonics::read( const std::string& meshPath, bool binaryMode /*= true*/ )
{
	if (binaryMode)
	{
		ifstream ifs(meshPath.c_str(), ios::binary);
		ifs.read((char*)&m_nEigFunc, sizeof(int));
		ifs.read((char*)&m_size, sizeof(int));
		double *buf = new double[m_nEigFunc * (m_size+1)];
		ifs.read((char*)buf,sizeof(double)*m_nEigFunc*(m_size+1));

		m_func.resize(m_nEigFunc);
		for (int i = 0; i < m_nEigFunc; ++i)
		{
			m_func[i].m_vec.resize(m_size);
			m_func[i].m_val = buf[i*(m_size+1)];
			for (int j = 0; j < m_size; ++j)
				m_func[i].m_vec[j] = buf[i*(m_size+1)+j+1];
		}

		delete []buf;
	}
	else
	{
		ifstream ifs(meshPath.c_str(), ios::binary);
		ifs.seekg (0, ios::end);
		int length = (int)ifs.tellg();
		ifs.seekg (0, ios::beg);
		char *buffer = new char[length];
		ifs.read(buffer, length);
		ifs.close();
	
		istringstream iss (buffer, istringstream::in);
		iss >> m_nEigFunc;
		iss >> m_size;
		m_func.resize(m_nEigFunc);
		for (int i = 0; i < m_nEigFunc; ++i)
		{
			m_func[i].m_vec.resize(m_size);
			iss >> m_func[i].m_val;
			for (int j = 0; j < m_size; ++j)
				iss >>m_func[i].m_vec[j];
		}
		delete []buffer;
	}
	
	cout << "MHB loaded from " << meshPath << endl;
}

MeshFunction ManifoldHarmonics::getManifoldHarmonic( int k ) const
{
	if (k > m_nEigFunc)
		throw runtime_error("Invalid request for manifold harmonic");
	MeshFunction mf(m_size);
	for (int i = 0; i < m_size; ++i)
	{
		mf[i] = m_func[k].m_vec[i];
	}
	return mf;
}

void ManifoldHarmonics::dumpEigenValues( const std::string& pathEVL ) const
{
	ofstream ofs(pathEVL.c_str(), ios::trunc);
	for (auto iter = m_func.begin(); iter != m_func.end(); ++iter)
		ofs << iter->m_val << endl;
	ofs.close();
}


class ManifoldLaplaceHarmonics : public ManifoldHarmonics
{
public:
    bool decompLaplacian(Engine *ep, const CMesh *tmesh, int nEigFunc);
};

bool ManifoldLaplaceHarmonics::decompLaplacian( Engine *ep, const CMesh *tmesh, int nEigFunc )
{
	m_func.clear();

	const int nVertex = tmesh->getVerticesNum();
	m_size = nVertex;
	m_nEigFunc = min(m_size, nEigFunc);

	mxArray *II, *JJ, *SS, *AA, *evecs, *evals, *Numv;
	AA = mxCreateDoubleMatrix(nVertex, 1, mxREAL);
	double *aa = mxGetPr(AA);
	Numv = mxCreateDoubleMatrix(1, 1, mxREAL);
	double *numv = mxGetPr(Numv);	
	numv[0] = m_nEigFunc;			// number of eigen vectors to be computed
	vector<int> IIv;
	vector<int> JJv;
	vector<double> SSv;
	vector<double> diagW;
	diagW.resize(nVertex, 0);
	
	for(int i = 0; i < nVertex; i++)	//for each vertex
	{
		double Av;
		tmesh->calVertexLBO(i, IIv, JJv, SSv, Av, diagW);
		aa[i] = Av;		//mixed area
	}
	
	for(int i = 0; i < nVertex; i++)
	{
		IIv.push_back(i+1);
		JJv.push_back(i+1);
		SSv.push_back(diagW[i]);
	}

	int ns = (int) IIv.size();
	II = mxCreateDoubleMatrix(ns, 1, mxREAL);
	JJ = mxCreateDoubleMatrix(ns, 1, mxREAL);
	SS = mxCreateDoubleMatrix(ns, 1, mxREAL);
	double *ii = mxGetPr(II);
	double *jj = mxGetPr(JJ);
	double *ss = mxGetPr(SS);
	std::copy(IIv.begin(), IIv.end(), ii);
	std::copy(JJv.begin(), JJv.end(), jj);
	std::copy(SSv.begin(), SSv.end(), ss);

	engPutVariable(ep, "II", II);
	engPutVariable(ep, "JJ", JJ);
	engPutVariable(ep, "SS", SS);
	engPutVariable(ep, "AA", AA);
	engPutVariable(ep, "Numv", Numv);

	engEvalString(ep, "[evecs,evals] = hspeigs(II,JJ,SS,AA,Numv);");

	evecs = engGetVariable(ep, "evecs");		
	double *evec = mxGetPr(evecs);				//eigenvectors
	evals = engGetVariable(ep, "evals");		
	double *eval = mxGetPr(evals);				//eigenvalues

	m_func.reserve(m_nEigFunc);
	for(int i = 0; i < m_nEigFunc; i++)
	{
		m_func.push_back(ManifoldBasis());

		m_func[i].m_vec.reserve(nVertex);
		for(int j = 0; j < nVertex; j++)
		{
			m_func[i].m_vec.push_back(evec[i*nVertex+j]);
		}
		m_func[i].m_val = abs(eval[i]);		// always non-negative
	}

	mxDestroyArray(evecs);
	mxDestroyArray(evals);
	mxDestroyArray(AA);
	mxDestroyArray(II);
	mxDestroyArray(JJ);
	mxDestroyArray(SS);
	mxDestroyArray(Numv);

	return true;
}

void MeshLaplacian::decompose( ManifoldHarmonics& mhb, int nEig, Engine *ep ) const
{
    assert(mLaplacianConstructed);
    assert(nEig > 0);

    std::vector<int> vII, vJJ;
    std::vector<double> vSS, vWeights;
    mLS.convertToCOO(vII, vJJ, vSS, ZGeom::MAT_FULL);
    mW.getDiagonal(vWeights);

    mhb.m_func.clear();
    mhb.m_size = this->mOrder;
    mhb.m_nEigFunc = min(mhb.m_size, nEig);

    mxArray *II, *JJ, *SS, *AA, *evecs, *evals, *NUMV;

    AA = mxCreateDoubleMatrix(mOrder, 1, mxREAL);
    double *aa = mxGetPr(AA);
    assert((int)vWeights.size() == mhb.m_size);
    std::copy(vWeights.begin(), vWeights.end(), aa);

    NUMV = mxCreateDoubleMatrix(1, 1, mxREAL);
    double *numv = mxGetPr(NUMV);	
    numv[0] = mhb.m_nEigFunc;			// number of eigen vectors to be computed

    int ns = (int) vII.size();
    II = mxCreateDoubleMatrix(ns, 1, mxREAL);
    JJ = mxCreateDoubleMatrix(ns, 1, mxREAL);
    SS = mxCreateDoubleMatrix(ns, 1, mxREAL);
    double *ii = mxGetPr(II);
    double *jj = mxGetPr(JJ);
    double *ss = mxGetPr(SS);
    std::copy(vII.begin(), vII.end(), ii);
    std::copy(vJJ.begin(), vJJ.end(), jj);
    std::copy(vSS.begin(), vSS.end(), ss);

    engPutVariable(ep, "II", II);
    engPutVariable(ep, "JJ", JJ);
    engPutVariable(ep, "SS", SS);
    engPutVariable(ep, "AA", AA);
    engPutVariable(ep, "Numv", NUMV);

    engEvalString(ep, "[evecs,evals] = hspeigs(II,JJ,SS,AA,Numv);");

    evecs = engGetVariable(ep, "evecs");		
    double *evec = mxGetPr(evecs);				//eigenvectors
    evals = engGetVariable(ep, "evals");		
    double *eval = mxGetPr(evals);				//eigenvalues

    mhb.m_func.reserve(mhb.m_nEigFunc);
    for(int i = 0; i < mhb.m_nEigFunc; i++)
    {
        mhb.m_func.push_back(ManifoldBasis());
        mhb.m_func[i].m_vec.reserve(mOrder);
        for(int j = 0; j < mOrder; j++)
        {
            mhb.m_func[i].m_vec.push_back(evec[i*mOrder+j]);
        }
        mhb.m_func[i].m_val = std::fabs(eval[i]);		// always non-negative
    }

    mxDestroyArray(evecs);
    mxDestroyArray(evals);
    mxDestroyArray(AA);
    mxDestroyArray(II);
    mxDestroyArray(JJ);
    mxDestroyArray(SS);
    mxDestroyArray(NUMV);
}

bool CMesh::calVertexLBO(int i, vector<int>& Iv, vector<int>& Jv, vector<double>& Sv, double& Av, vector<double>& tw) const
{
	if( i < 0 || i >= m_nVertex) return false;
	double avgEdgeLen = getAvgEdgeLength();
	double amix = 0.0;		// mixed area
	int bs = -1;
	for( int j = 0; j < m_pVertex[i].mOutValence; j++ ) 
	{
		// get triangle edges
		int e0 = m_pVertex[i].m_piEdge[j];
		int e1 = m_pHalfEdge[e0].m_iNextEdge;
		int e2 = m_pHalfEdge[e1].m_iNextEdge;
		int vj = m_pHalfEdge[e0].m_iVertex[1];
		if (m_pVertex[i].m_bIsBoundary && m_pHalfEdge[e2].m_iTwinEdge < 0)   // boundary vertex
		{
			bs = e2;
		}
		// get edge lengths
		double len0 = getHalfEdgeLen(e0) / avgEdgeLen;
		double len1 = getHalfEdgeLen(e1) / avgEdgeLen;
		double len2 = getHalfEdgeLen(e2) / avgEdgeLen;
		double cota, cota1 = 0, cota2 = 0;
		amix += calHalfAreaMixed(len0, len1, len2, cota1);

		// twin edge
		e0 = m_pHalfEdge[e0].m_iTwinEdge;
		if (e0 > -1)
		{
			e1 = m_pHalfEdge[e0].m_iNextEdge;
			e2 = m_pHalfEdge[e1].m_iNextEdge;
			// get edge lengths
			len1 = getHalfEdgeLen(e1) / avgEdgeLen;
			len2 = getHalfEdgeLen(e2) / avgEdgeLen;
			// compute corner angle by cotangent law 
			amix += calHalfAreaMixed(len0, len1, len2, cota2);
		}
		cota = (cota1 + cota2 ) / 4.0;

		Iv.push_back(i+1);
		Jv.push_back(vj+1);
		Sv.push_back(cota);
		tw[i] -= cota;

		Iv.push_back(vj+1);
		Jv.push_back(i+1);
		Sv.push_back(cota);
		tw[vj] -= cota;
	}

	if(bs >- 1)
	{
		int e1 = m_pHalfEdge[bs].m_iNextEdge;
		int	e2 = m_pHalfEdge[e1].m_iNextEdge;
		int vj = m_pHalfEdge[e2].m_iVertex[1];
		assert(vj == m_pHalfEdge[bs].m_iVertex[0]);
		// get edge lengths
		double len0 = getHalfEdgeLen(bs) / avgEdgeLen;
		double len1 = getHalfEdgeLen(e1) / avgEdgeLen;
		double len2 = getHalfEdgeLen(e2) / avgEdgeLen;
		// compute corner angle by cotangent law 
		double cota2;
		amix += calHalfAreaMixed(len0, len1, len2, cota2);
		double cota = cota2 / 4.0;		

		Iv.push_back(i+1);
		Jv.push_back(vj+1);
		Sv.push_back(cota);
		tw[i] -= cota;

		Iv.push_back(vj+1);
		Jv.push_back(i+1);
		Sv.push_back(cota);		
		tw[vj] -= cota;
	}

	Av = amix;
	return true;
}

bool CMesh::calVertexLBO2( int i, std::vector<int>& Iv, std::vector<int>& Jv, std::vector<double>& Sv, double& Av, std::vector<double>& tw ) const
{
	if( i < 0 || i >= m_nVertex) return false;

	double avgEdgeLen = getAvgEdgeLength();
	double amix = 0.0;		// mixed area
	int bs = -1;
	for( int j = 0; j < m_pVertex[i].mOutValence; j++ ) 
	{
		// get triangle edges
		int e0 = m_pVertex[i].m_piEdge[j];
		int e1 = m_pHalfEdge[e0].m_iNextEdge;
		int e2 = m_pHalfEdge[e1].m_iNextEdge;
		int vj = m_pHalfEdge[e0].m_iVertex[1];
		if (m_pVertex[i].m_bIsBoundary && m_pHalfEdge[e2].m_iTwinEdge < 0)   // boundary vertex
		{
			bs = e2;
		}
		// get edge lengths
		double len0 = getHalfEdgeLen(e0) / avgEdgeLen;
		double len1 = getHalfEdgeLen(e1) / avgEdgeLen;
		double len2 = getHalfEdgeLen(e2) / avgEdgeLen;
		double cota, cota1 = 0, cota2 = 0;
		amix += calHalfAreaMixed(len0, len1, len2, cota1);

		// twin edge
		e0 = m_pHalfEdge[e0].m_iTwinEdge;
		if (e0 > -1)
		{
			e1 = m_pHalfEdge[e0].m_iNextEdge;
			e2 = m_pHalfEdge[e1].m_iNextEdge;
			// get edge lengths
			len1 = getHalfEdgeLen(e1) / avgEdgeLen;
			len2 = getHalfEdgeLen(e2) / avgEdgeLen;
			// compute corner angle by cotangent law 
			amix += calHalfAreaMixed(len0, len1, len2, cota2);
		}
		cota = (cota1 + cota2 ) / 2.0;

		Iv.push_back(i+1);
		Jv.push_back(vj+1);
		Sv.push_back(cota);
		tw[i] -= cota;

// 		Iv.push_back(vj+1);
// 		Jv.push_back(i+1);
// 		Sv.push_back(cota);
// 		tw[vj] -= cota;
	}

	if(bs >- 1)
	{
		int e1 = m_pHalfEdge[bs].m_iNextEdge;
		int	e2 = m_pHalfEdge[e1].m_iNextEdge;
		int vj = m_pHalfEdge[e2].m_iVertex[1];
		assert(vj == m_pHalfEdge[bs].m_iVertex[0]);
		// get edge lengths
		double len0 = getHalfEdgeLen(bs) / avgEdgeLen;
		double len1 = getHalfEdgeLen(e1) / avgEdgeLen;
		double len2 = getHalfEdgeLen(e2) / avgEdgeLen;
		// compute corner angle by cotangent law 
		double cota2;
		amix += calHalfAreaMixed(len0, len1, len2, cota2);
		double cota = cota2 / 2.0;		

		Iv.push_back(i+1);
		Jv.push_back(vj+1);
		Sv.push_back(cota);
		tw[i] -= cota;

// 		Iv.push_back(vj+1);
// 		Jv.push_back(i+1);
// 		Sv.push_back(cota);		
// 		tw[vj] -= cota;
	}

	Av = amix;
	return true;
}
